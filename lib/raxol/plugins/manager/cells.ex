defmodule Raxol.Plugins.Manager.Cells do
  @moduledoc """
  Handles cell processing functionality.
  Provides functions for processing and transforming cells through plugins.
  """

  require Raxol.Core.Runtime.Log

  alias Raxol.Plugins.{CellProcessor, Lifecycle}
  alias Raxol.Plugins.Manager.Core

  @doc """
  Allows plugins to process or replace cells generated by the renderer.
  Delegates processing to `Raxol.Plugins.CellProcessor`.

  Returns `{:ok, updated_manager, processed_cells, collected_commands}`.
  """
  def handle_cells(%Core{} = manager, cells, emulator_state)
      when is_list(cells) do
    # Delegate to the CellProcessor module
    CellProcessor.process(manager, cells, emulator_state)
  end

  @doc """
  Processes a single cell through all enabled plugins.
  Returns {:ok, updated_manager, processed_cell} or {:error, reason}.
  """
  def process_cell(%Core{} = manager, cell, emulator_state) do
    Enum.reduce_while(manager.plugins, {:ok, manager, cell}, fn {_name, plugin},
                                                                {:ok,
                                                                 acc_manager,
                                                                 acc_cell} ->
      if plugin.enabled do
        # Get the module from the struct
        module = plugin.__struct__

        # Check if module implements process_cell
        if function_exported?(module, :process_cell, 3) do
          case module.process_cell(plugin, acc_cell, emulator_state) do
            {:ok, updated_plugin, processed_cell} ->
              updated_manager =
                Core.update_plugins(
                  acc_manager,
                  Map.put(acc_manager.plugins, plugin.name, updated_plugin)
                )

              {:cont, {:ok, updated_manager, processed_cell}}

            {:error, reason} ->
              {:halt, {:error, reason}}
          end
        else
          # Plugin doesn't implement cell processing
          {:cont, {:ok, acc_manager, acc_cell}}
        end
      else
        # Plugin disabled
        {:cont, {:ok, acc_manager, acc_cell}}
      end
    end)
  end

  @doc """
  Collects cell-related commands from all enabled plugins.
  Returns {:ok, updated_manager, commands}.
  """
  def collect_cell_commands(%Core{} = manager) do
    Enum.reduce(manager.plugins, {:ok, manager, []}, fn {_name, plugin},
                                                        {:ok, acc_manager,
                                                         acc_commands} ->
      if plugin.enabled do
        # Get the module from the struct
        module = plugin.__struct__

        # Check if module implements get_cell_commands
        if function_exported?(module, :get_cell_commands, 1) do
          case module.get_cell_commands(plugin) do
            {:ok, updated_plugin, commands} ->
              updated_manager =
                Core.update_plugins(
                  acc_manager,
                  Map.put(acc_manager.plugins, plugin.name, updated_plugin)
                )

              {:ok, updated_manager, commands ++ acc_commands}

            # No commands returned
            {:ok, updated_plugin} ->
              updated_manager =
                Core.update_plugins(
                  acc_manager,
                  Map.put(acc_manager.plugins, plugin.name, updated_plugin)
                )

              {:ok, updated_manager, acc_commands}

            # Allow plugins to just return commands if state doesn't change
            commands when is_list(commands) ->
              {:ok, acc_manager, commands ++ acc_commands}
          end
        else
          # Plugin doesn't implement command collection
          {:ok, acc_manager, acc_commands}
        end
      else
        # Plugin disabled
        {:ok, acc_manager, acc_commands}
      end
    end)
  end
end
