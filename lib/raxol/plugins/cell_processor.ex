defmodule Raxol.Plugins.CellProcessor do
  @moduledoc """
  Handles the processing of rendered cells, allowing plugins to modify or replace them.
  Especially targets placeholder cells generated by the rendering pipeline.
  """

  require Logger

  alias Raxol.Plugins.Manager.Core

  @doc """
  Processes a list of cells, allowing relevant plugins to handle placeholders.

  Iterates through the list of cells. If a cell is a placeholder (e.g.,
  `%{type: :placeholder, value: :image, ...}`), it identifies the responsible
  plugin (based on `placeholder_value`) and calls that plugin's `handle_cells/3`
  callback.

  The plugin's callback receives the placeholder cell map, the current emulator state,
  and its own current plugin state. It should return:
  - `{:ok, updated_plugin_state, list_of_replacement_cells, list_of_commands}`:
    The placeholder is replaced by `list_of_replacement_cells`, and the plugin's
    state is updated. `list_of_commands` are collected.
  - `{:cont, updated_plugin_state}`: The plugin declines to handle the placeholder.
    Its state is updated, but the placeholder is effectively removed (replaced by []).
  - `{:error, reason}`: An error occurred.

  Regular cells (non-placeholders) are passed through unchanged.

  Returns `{:ok, updated_manager_state, final_cell_list, collected_commands}` where
  `updated_manager_state` reflects any changes to plugin states.
  """
  @spec process(Core.t(), list(map()), map()) ::
          {:ok, Core.t(), list(map()), list(binary())}
          # In case of error during processing
          | {:error, any()}
  def process(%Core{} = manager, cells, emulator_state)
      when is_list(cells) do
    Logger.debug("[CellProcessor.process] Processing #{length(cells)} cells...")

    # Accumulator: {updated_manager, processed_cells_list_reversed, collected_commands_list}
    initial_acc = {manager, [], []}

    {final_manager, final_cells_rev, final_commands} =
      Enum.reduce(cells, initial_acc, fn cell,
                                         {acc_manager, processed_cells_rev,
                                          acc_commands} ->
        # Check if the cell is a placeholder potentially handled by a plugin
        case cell do
          %{type: :placeholder, value: placeholder_value} = placeholder_cell ->
            Logger.debug(
              "[CellProcessor.process] Found placeholder: #{inspect(placeholder_value)}"
            )

            # Determine the responsible plugin name based on the placeholder type
            plugin_name = determine_plugin_for_placeholder(placeholder_value)

            # Delegate to a helper function to handle the placeholder with the specific plugin
            {manager_after_processing, replacement_cells, new_commands} =
              if plugin_name do
                handle_placeholder_with_plugin(
                  acc_manager,
                  plugin_name,
                  placeholder_cell,
                  emulator_state
                )
              else
                Logger.warning(
                  "[CellProcessor.process] Unknown placeholder value: #{placeholder_value}. Skipping."
                )

                # Return the accumulator state unchanged if no plugin is found
                {acc_manager, [], []}
              end

            # Combine results for the next iteration
            # Use the manager state resulting from the inner processing.
            {manager_after_processing, replacement_cells ++ processed_cells_rev,
             acc_commands ++ new_commands}

          # Original cell was not a placeholder, keep it
          valid_cell ->
            # Prepend to the reversed list, pass original acc_manager forward
            {acc_manager, [valid_cell | processed_cells_rev], acc_commands}
        end
      end)

    # End of Enum.reduce

    final_cells = Enum.reverse(final_cells_rev)

    Logger.debug(
      "[CellProcessor.process] Finished. Final Cells: #{length(final_cells)}, Commands: #{length(final_commands)}"
    )

    # Return the final manager state accumulated through the process
    {:ok, final_manager, final_cells, final_commands}
  end

  # --- Private Helper Functions ---

  @spec determine_plugin_for_placeholder(atom()) :: String.t() | nil
  defp determine_plugin_for_placeholder(:image), do: "image"
  defp determine_plugin_for_placeholder(:chart), do: "visualization"
  defp determine_plugin_for_placeholder(:treemap), do: "visualization"
  # Add other placeholder types and their corresponding plugin names here
  defp determine_plugin_for_placeholder(_other), do: nil

  # Handles the interaction with a specific plugin for a given placeholder.
  # Returns {updated_manager, replacement_cells, new_commands}
  @spec handle_placeholder_with_plugin(
          Core.t(),
          String.t(),
          map(),
          map()
        ) ::
          {Core.t(), list(map()), list(binary())}
  defp handle_placeholder_with_plugin(
         manager,
         plugin_name,
         placeholder_cell,
         emulator_state
       ) do
    case Map.get(manager.plugins, plugin_name) do
      nil ->
        Logger.warning(
          "[CellProcessor.process] Plugin '#{plugin_name}' not loaded for placeholder '#{Map.get(placeholder_cell, :value)}'. Skipping."
        )

        # Return default accumulator if plugin not found
        {manager, [], []}

      plugin ->
        # Call only the relevant plugin's handle_cells
        if plugin.enabled and
             function_exported?(plugin.__struct__, :handle_cells, 3) do
          log_plugin_call_details(plugin_name, plugin, placeholder_cell)

          try do
            # Call the plugin's handle_cells function
            handle_cells_result =
              plugin.__struct__.handle_cells(
                placeholder_cell,
                emulator_state,
                plugin
              )

            # Process the result from the plugin
            process_plugin_handle_cells_result(
              manager,
              plugin_name,
              handle_cells_result
            )
          rescue
            e ->
              Logger.error(
                "[CellProcessor.process] RESCUED Error calling #{plugin_name}.handle_cells: #{inspect(e)}. Placeholder was: #{inspect(placeholder_cell)}"
              )

              # Return default accumulator on error
              {manager, [], []}
          end
        else
          # Plugin exists but is disabled or doesn't implement handle_cells
          Logger.debug(
            "[CellProcessor.process] Plugin '#{plugin_name}' disabled or does not implement handle_cells/3. Skipping."
          )

          {manager, [], []}
        end
    end
  end

  # Logs details before calling the plugin's handle_cells
  defp log_plugin_call_details(plugin_name, plugin, placeholder_cell) do
    # Log state *before* calling plugin, especially for ImagePlugin
    if plugin_name == "image" do
      Logger.debug(
        "[CellProcessor.process] Before calling ImagePlugin.handle_cells. sequence_just_generated: #{inspect(Map.get(plugin, :sequence_just_generated))}"
      )
    end

    # Log the opts specifically
    Logger.debug(
      "[CellProcessor.process] Placeholder opts: #{inspect(Map.get(placeholder_cell, :opts))}"
    )

    Logger.debug(
      "[CellProcessor.process] Calling #{plugin_name}.handle_cells for placeholder...
CELL DATA: #{inspect(placeholder_cell)}"
    )
  end

  # Processes the return value from the plugin's handle_cells function.
  # Returns {updated_manager, replacement_cells, new_commands}
  @spec process_plugin_handle_cells_result(Core.t(), String.t(), any()) ::
          {Core.t(), list(map()), list(binary())}
  defp process_plugin_handle_cells_result(
         manager,
         plugin_name,
         handle_cells_result
       ) do
    case handle_cells_result do
      # Plugin handled it, returning cells and commands
      {:ok, updated_plugin_state, plugin_cells, plugin_commands}
      when is_list(plugin_cells) ->
        log_plugin_handled_details(
          plugin_name,
          updated_plugin_state,
          plugin_cells,
          plugin_commands
        )

        # Update manager state
        updated_manager = %{
          manager
          | plugins: Map.put(manager.plugins, plugin_name, updated_plugin_state)
        }

        # Return the result (handled = true)
        {updated_manager, plugin_cells, plugin_commands}

      # Plugin declined or returned unexpected success format (invalid cells)
      {:ok, updated_plugin_state, _invalid_cells, plugin_commands} ->
        Logger.warning(
          "[CellProcessor.process] Plugin #{plugin_name} handled placeholder but returned invalid cell format. Treating as decline."
        )

        updated_manager = %{
          manager
          | plugins: Map.put(manager.plugins, plugin_name, updated_plugin_state)
        }

        # Return default accumulator (handled = false), but with updated manager and commands
        {updated_manager, [], plugin_commands}

      # Handle cases where plugin declines (:cont)
      {:cont, updated_plugin_state} ->
        log_plugin_declined_details(plugin_name, updated_plugin_state)

        updated_manager = %{
          manager
          | plugins: Map.put(manager.plugins, plugin_name, updated_plugin_state)
        }

        # Return default accumulator (handled = false), but with updated manager
        {updated_manager, [], []}

      # {:error, _} or other unexpected return
      _ ->
        Logger.warning(
          "[CellProcessor.process] Plugin #{plugin_name} returned unexpected value from handle_cells. Skipping."
        )

        # Return default accumulator
        {manager, [], []}
    end
  end

  # Logs details when a plugin successfully handles a placeholder
  defp log_plugin_handled_details(
         plugin_name,
         updated_plugin_state,
         plugin_cells,
         plugin_commands
       ) do
    if plugin_name == "image" do
      Logger.debug(
        "[CellProcessor.process] After ImagePlugin.handle_cells returned {:ok, ...}. sequence_just_generated: #{inspect(Map.get(updated_plugin_state, :sequence_just_generated))}"
      )
    end

    Logger.debug(
      "[CellProcessor.process] Plugin #{plugin_name} handled placeholder. Cells: #{length(plugin_cells)}, Commands: #{length(plugin_commands)}"
    )
  end

  # Logs details when a plugin declines to handle a placeholder
  defp log_plugin_declined_details(plugin_name, updated_plugin_state) do
    Logger.debug(
      "[CellProcessor.process] Plugin #{plugin_name} returned :cont. State Flag: #{inspect(Map.get(updated_plugin_state, :sequence_just_generated))}"
    )

    if plugin_name == "image" do
      Logger.debug(
        "[CellProcessor.process] After ImagePlugin.handle_cells returned {:cont, ...}. sequence_just_generated: #{inspect(Map.get(updated_plugin_state, :sequence_just_generated))}"
      )
    end

    Logger.debug(
      "[CellProcessor.process] Plugin #{plugin_name} declined placeholder."
    )
  end
end
