defmodule Raxol.Components.Input.MultiLineInput do
  @moduledoc """
  A multi-line input component with line wrapping, vertical scrolling, and text manipulation.

  ## Props
    * `:value` - Current text value (default: "")
    * `:placeholder` - Placeholder text when empty (default: "")
    * `:width` - Width of the input field (default: 40)
    * `:height` - Height of the input field (default: 10)
    * `:style` - Style map for customizing appearance
      * `:text_color` - Color of the text (default: :white)
      * `:placeholder_color` - Color of placeholder text (default: :gray)
      * `:selection_color` - Color of selected text (default: :blue)
      * `:cursor_color` - Color of the cursor (default: :white)
      * `:line_numbers` - Whether to show line numbers (default: false)
      * `:line_number_color` - Color of line numbers (default: :gray)
    * `:wrap` - Line wrapping mode (default: :word)
      * `:none` - No wrapping
      * `:char` - Wrap at character boundaries
      * `:word` - Wrap at word boundaries
    * `:on_change` - Function called when text changes
  """

  use Raxol.UI.Components.Base.Component

  require Logger
  alias Raxol.Components.Input.TextWrapping
  alias Raxol.Components.Input.MultiLineInput.TextHelper
  alias Raxol.Components.Input.MultiLineInput.NavigationHelper
  alias Raxol.Components.Input.MultiLineInput.RenderHelper
  alias Raxol.Components.Input.MultiLineInput.EventHandler
  alias Raxol.Components.Input.MultiLineInput.ClipboardHelper
  require Raxol.View.Elements

  # Define default values before using them in struct
  @default_width 40
  @default_height 10
  @default_style %{
    text_color: :white,
    placeholder_color: :gray,
    selection_color: :blue,
    cursor_color: :white,
    line_numbers: false,
    line_number_color: :gray
  }

  # Explicitly define the struct fields
  defstruct value: "",
            placeholder: "",
            width: @default_width,
            height: @default_height,
            style: @default_style,
            wrap: :word,
            # Use tuple for cursor position {row, col}
            cursor_pos: {0, 0},
            # Use tuple for scroll offset {row, col}
            scroll_offset: {0, 0},
            selection_start: nil,
            selection_end: nil,
            # History for undo/redo
            history: nil,
            # Need to track if Shift is held for selection extension
            # This might need to be part of event data or handled differently
            shift_held: false,
            focused: false,
            on_change: nil,
            id: nil,
            # Cache lines to avoid recalculating on every render/update
            lines: [""]

  # Add State alias for clarity in helpers
  alias __MODULE__, as: State

  # Need Command alias for clipboard
  alias Raxol.Core.Runtime.Command

  @impl Raxol.UI.Components.Base.Component
  def init(props) do
    value = props[:value] || ""
    width = props[:width] || @default_width
    wrap = props[:wrap] || :word
    lines = TextHelper.split_into_lines(value, width, wrap)

    %State{
      value: value,
      placeholder: props[:placeholder] || "",
      width: width,
      height: props[:height] || @default_height,
      style: Map.merge(@default_style, props[:style] || %{}),
      wrap: wrap,
      cursor_pos: {0, 0},
      scroll_offset: {0, 0},
      selection_start: nil,
      selection_end: nil,
      # Initialize history
      history: Raxol.History.new(),
      shift_held: false,
      focused: false,
      on_change: props[:on_change],
      lines: lines,
      # Ensure ID
      id: props[:id] || Ecto.UUID.generate()
    }
  end

  # Consolidate event handling here, calling helpers
  @impl Raxol.UI.Components.Base.Component
  def handle_event(event, %State{} = state) do
    # Delegate to EventHandler first to translate to update messages
    EventHandler.handle_event(event, state)
  end

  # Handle update messages generated by EventHandler
  @impl Raxol.UI.Components.Base.Component
  def update({:input, char}, %State{} = state) do
    # Ensure char is a single character codepoint
    case String.to_charlist(char) do
      [codepoint] ->
        new_state = TextHelper.insert_char(state, codepoint)

        trigger_on_change(
          {:noreply, ensure_cursor_visible(new_state), nil},
          state
        )

      _ ->
        # Ignore multi-character inputs for now
        {:noreply, state, nil}
    end
  end

  def update({:backspace}, %State{} = state) do
    new_state = TextHelper.delete_backward(state)
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), nil}, state)
  end

  def update({:delete}, %State{} = state) do
    new_state = TextHelper.delete_forward(state)
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), nil}, state)
  end

  def update({:enter}, %State{} = state) do
    new_state = TextHelper.insert_newline(state)
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), nil}, state)
  end

  # --- Basic Movement (Clears Selection) ---
  def update({:move_cursor, direction}, %State{} = state)
      when direction in [:left, :right, :up, :down] do
    new_state =
      NavigationHelper.move_cursor(state, direction)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_line_start}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_to_start_of_line(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_line_end}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_to_end_of_line(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_page, direction}, %State{} = state)
      when direction in [:up, :down] do
    new_state =
      NavigationHelper.move_cursor_page_down(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_doc_start}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_to_start_of_document(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_doc_end}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_to_end_of_document(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  # --- Movement for Mouse Click ---
  def update({:move_cursor_to, {row, col}}, %State{} = state) do
    # TODO: Validate row/col against lines
    new_state =
      %{state | cursor_pos: {row, col}}
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  # --- Selection Handling ---
  def update({:select_and_move, direction}, %State{} = state) do
    original_cursor_pos = state.cursor_pos

    # Determine the new cursor position based on direction
    moved_state =
      case direction do
        :left ->
          NavigationHelper.move_cursor(state, :left)

        :right ->
          NavigationHelper.move_cursor(state, :right)

        :up ->
          NavigationHelper.move_cursor(state, :up)

        :down ->
          NavigationHelper.move_cursor(state, :down)

        :line_start ->
          NavigationHelper.move_cursor_to_start_of_line(state)

        :line_end ->
          NavigationHelper.move_cursor_to_end_of_line(state)

        :page_up ->
          NavigationHelper.move_cursor_page_up(state)

        :page_down ->
          NavigationHelper.move_cursor_page_down(state)

        :doc_start ->
          NavigationHelper.move_cursor_to_start_of_document(state)

        :doc_end ->
          NavigationHelper.move_cursor_to_end_of_document(state)
          # TODO: Add word movements
      end

    new_cursor_pos = moved_state.cursor_pos

    # Update selection: If no selection start, set it to original pos.
    # Always update selection end to the new cursor pos.
    selection_start = state.selection_start || original_cursor_pos

    final_state = %{
      moved_state
      | selection_start: selection_start,
        selection_end: new_cursor_pos
    }

    {:noreply, ensure_cursor_visible(final_state), nil}
  end

  def update({:select_all}, %State{} = state) do
    new_state = NavigationHelper.select_all(state)
    {:noreply, new_state, nil}
  end

  # --- Clipboard Operations ---
  def update({:copy}, %State{} = state) do
    ClipboardHelper.copy_selection(state)
  end

  def update({:cut}, %State{} = state) do
    # Cut returns {new_state, cmd}, need to trigger change
    {new_state, cmd} = ClipboardHelper.cut_selection(state)
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), cmd}, state)
  end

  def update({:paste}, %State{} = state) do
    ClipboardHelper.paste_clipboard(state)
  end

  # This is called when the clipboard content is received (e.g., from plugin)
  def update({:clipboard_content, content}, %State{} = state)
      when is_binary(content) do
    new_state = ClipboardHelper.handle_clipboard_content(content, state)
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), nil}, state)
  end

  # Ignore non-binary content
  def update({:clipboard_content, _}, %State{} = state) do
    {:noreply, state, nil}
  end

  # --- Focus Handling ---
  def update(:focus, %State{} = state) do
    {:noreply, %{state | focused: true}, nil}
  end

  def update(:blur, %State{} = state) do
    # Clear selection on blur
    {:noreply,
     %{state | focused: false, selection_start: nil, selection_end: nil}, nil}
  end

  # --- Catch-all for other messages ---
  def update(msg, state) do
    Logger.warn("[MultiLineInput] Unhandled update message: #{inspect(msg)}")
    {:noreply, state, nil}
  end

  @impl Raxol.UI.Components.Base.Component
  def render(%State{} = state, %{focused: focused} = context) do
    # Get theme from context if available, otherwise use a default mock/empty theme
    theme =
      Map.get(context, :theme, %Raxol.UI.Theming.Theme{component_styles: %{}})

    # Use RenderHelper to get the grid of cells
    cell_grid = RenderHelper.render_view(%{state | focused: focused}, theme)

    # Convert the cell grid into view elements (e.g., using :text elements)
    view_elements =
      Enum.with_index(cell_grid, fn row_cells, _y ->
        Raxol.View.Elements.text(content: row_cells)
        # TODO: Consider rendering line numbers if enabled
      end)

    # Wrap in a box or container if needed
    # TODO: Add border, focus styling based on state.focused
    # style: Style.new(border: if(state.focused, do: ..., else: ...))
    Raxol.View.Elements.box do
      view_elements
    end
  end

  # --- Internal Helpers ---

  # Ensures the cursor is visible within the viewport, adjusting scroll_offset.
  # This is a simplified version.
  defp ensure_cursor_visible(%State{} = state) do
    {cursor_row, _cursor_col} = state.cursor_pos
    {scroll_row, scroll_col} = state.scroll_offset
    height = state.height
    # width = state.width # Needed for horizontal scrolling

    new_scroll_row =
      cond do
        # Scroll up
        cursor_row < scroll_row -> cursor_row
        # Scroll down
        cursor_row >= scroll_row + height -> cursor_row - height + 1
        true -> scroll_row
      end

    # TODO: Implement horizontal scrolling adjustment based on cursor_col and scroll_col
    new_scroll_col = scroll_col

    # Update lines cache if needed (e.g., after text modification)
    # Re-calculate lines based on potentially new value
    # This might be inefficient if called too often. Consider optimizing.
    new_lines =
      TextHelper.split_into_lines(state.value, state.width, state.wrap)

    %{state | scroll_offset: {new_scroll_row, new_scroll_col}, lines: new_lines}
  end

  # Calls the on_change callback if defined and value changed
  defp trigger_on_change({:noreply, new_state, cmd}, old_state) do
    if new_state.value != old_state.value and
         is_function(new_state.on_change, 1) do
      # TODO: How to invoke the callback? Needs context or message passing.
      # Maybe return a specific command or structure?
      # For now, just logging it.
      Logger.debug("Value changed, would call on_change: #{new_state.id}")
      # new_state.on_change.(new_state.value)
    end

    {:noreply, new_state, cmd}
  end

  # Pass through other results
  defp trigger_on_change(other, _old_state), do: other
end
