defmodule Raxol.Components.Input.MultiLineInput do
  @moduledoc """
  A multi-line input component with line wrapping, vertical scrolling, and text manipulation.

  ## Props
    * `:value` - Current text value (default: "")
    * `:placeholder` - Placeholder text when empty (default: "")
    * `:width` - Width of the input field (default: 40)
    * `:height` - Height of the input field (default: 10)
    * `:style` - Style map for customizing appearance
      * `:text_color` - Color of the text (default: :white)
      * `:placeholder_color` - Color of placeholder text (default: :gray)
      * `:selection_color` - Color of selected text (default: :blue)
      * `:cursor_color` - Color of the cursor (default: :white)
      * `:line_numbers` - Whether to show line numbers (default: false)
      * `:line_number_color` - Color of line numbers (default: :gray)
    * `:wrap` - Line wrapping mode (default: :word)
      * `:none` - No wrapping
      * `:char` - Wrap at character boundaries
      * `:word` - Wrap at word boundaries
    * `:on_change` - Function called when text changes
  """

  use Raxol.UI.Components.Base.Component, type: :input

  require Logger
  # alias Raxol.Components.Input.TextWrapping # Removed unused alias
  alias Raxol.Components.Input.MultiLineInput.TextHelper
  alias Raxol.Components.Input.MultiLineInput.NavigationHelper
  alias Raxol.Components.Input.MultiLineInput.RenderHelper
  alias Raxol.Components.Input.MultiLineInput.EventHandler
  alias Raxol.Components.Input.MultiLineInput.ClipboardHelper
  require Raxol.View.Elements

  # Define default values before using them in struct
  @default_width 40
  @default_height 10
  @default_style %{
    text_color: :white,
    placeholder_color: :gray,
    selection_color: :blue,
    cursor_color: :white,
    line_numbers: false,
    line_number_color: :gray
  }

  # Explicitly define the struct fields
  defstruct value: "",
            placeholder: "",
            width: @default_width,
            height: @default_height,
            style: @default_style,
            wrap: :word,
            # Use tuple for cursor position {row, col}
            cursor_pos: {0, 0},
            # Use tuple for scroll offset {row, col}
            scroll_offset: {0, 0},
            selection_start: nil,
            selection_end: nil,
            # History for undo/redo
            history: nil,
            # Need to track if Shift is held for selection extension
            # This might need to be part of event data or handled differently
            shift_held: false,
            focused: false,
            on_change: nil,
            id: nil,
            # Cache lines to avoid recalculating on every render/update
            lines: [""]

  # Add State alias for clarity in helpers
  alias __MODULE__, as: State

  alias Raxol.Terminal.Commands.History
  # Need Command alias for clipboard
  # alias Raxol.Core.Runtime.Command

  # Add aliases for helper modules
  alias Raxol.Components.Input.MultiLineInput.TextHelper
  alias Raxol.Components.Input.MultiLineInput.NavigationHelper
  alias Raxol.Components.Input.MultiLineInput.ClipboardHelper
  alias Raxol.Components.Input.MultiLineInput.RenderHelper

  @impl Raxol.UI.Components.Base.Component
  def init(props) do
    value = props[:value] || ""
    width = props[:width] || @default_width
    wrap = props[:wrap] || :word
    lines = TextHelper.split_into_lines(value, width, wrap)

    %State{
      value: value,
      placeholder: props[:placeholder] || "",
      width: width,
      height: props[:height] || @default_height,
      style: Map.merge(@default_style, props[:style] || %{}),
      wrap: wrap,
      cursor_pos: {0, 0},
      scroll_offset: {0, 0},
      selection_start: nil,
      selection_end: nil,
      # Initialize history
      history: History.new(100),
      shift_held: false,
      focused: false,
      on_change: props[:on_change],
      lines: lines,
      # Ensure ID
      id: props[:id] || Ecto.UUID.generate()
    }
  end

  # Consolidate event handling here, calling helpers
  @impl Raxol.UI.Components.Base.Component
  def handle_event(event, _context, %State{} = state) do
    # Delegate to EventHandler first to translate to update messages
    EventHandler.handle_event(event, state)
  end

  # Handle update messages generated by EventHandler
  @impl Raxol.UI.Components.Base.Component
  def update({:update_props, new_props}, %State{} = state) do
    # TODO: Validate props?
    new_state = Map.merge(state, new_props)
    # Re-calculate lines cache if value/width/wrap changed
    new_state = ensure_cursor_visible(new_state)
    {:noreply, new_state, nil}
  end

  def update({:input, char}, %State{} = state) do
    # Ensure char is a single character codepoint
    case String.to_charlist(char) do
      [codepoint] ->
        # Pass state and codepoint to insert_char
        state_after_insert = TextHelper.insert_char(state, codepoint)

        # Calculate new cursor position based on inserted char STRING
        {new_row, new_col} = TextHelper.calculate_new_position(state.cursor_pos.row, state.cursor_pos.col, char)

        # Update state with new value and cursor position
        new_state = %{
          state_after_insert |
          cursor_pos: {new_row, new_col}
        }

        trigger_on_change(
          {:noreply, ensure_cursor_visible(new_state), nil},
          state
        )

      _ ->
        # Ignore multi-character inputs for now
        {:noreply, state, nil}
    end
  end

  def update({:backspace}, %State{} = state) do
    # Check for selection first
    new_state =
      if elem(NavigationHelper.normalize_selection(state), 0) != nil do # Corrected check
        {s, _deleted} = TextHelper.delete_selection(state)
        s
      else
        TextHelper.handle_backspace_no_selection(state)
      end
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), nil}, state)
  end

  def update({:delete}, %State{} = state) do
    # Check for selection first
    new_state =
      if elem(NavigationHelper.normalize_selection(state), 0) != nil do # Corrected check
        {s, _deleted} = TextHelper.delete_selection(state)
        s
      else
        TextHelper.handle_delete_no_selection(state)
      end
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), nil}, state)
  end

  def update({:enter}, %State{} = state) do
    # Check for selection first and delete if present
    {state_after_delete, _} =
      if elem(NavigationHelper.normalize_selection(state), 0) != nil do # Corrected check
        TextHelper.delete_selection(state)
      else
        {state, ""}
      end

    # Insert newline character (codepoint 10)
    new_state = TextHelper.insert_char(state_after_delete, 10)
    trigger_on_change({:noreply, ensure_cursor_visible(new_state), nil}, state)
  end

  # --- Basic Movement (Clears Selection) ---
  def update({:move_cursor, direction}, %State{} = state)
      when direction in [:left, :right, :up, :down] do
    new_state =
      NavigationHelper.move_cursor(state, direction)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_line_start}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_line_start(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_line_end}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_line_end(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_page, direction}, %State{} = state)
      when direction in [:up, :down] do
    new_state =
      NavigationHelper.move_cursor_page(state, direction)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_doc_start}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_doc_start(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_doc_end}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor_doc_end(state)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  # --- Movement for Mouse Click ---
  def update({:move_cursor_to, {row, col}}, %State{} = state) do
    # TODO: Validate row/col against lines
    new_state =
      %{state | cursor_pos: {row, col}}
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  # --- Selection Handling ---
  def update({:select_and_move, direction}, %State{} = state) do
    original_cursor_pos = state.cursor_pos

    # Determine the new cursor position based on direction
    moved_state =
      case direction do
        :left ->
          NavigationHelper.move_cursor(state, :left)

        :right ->
          NavigationHelper.move_cursor(state, :right)

        :up ->
          NavigationHelper.move_cursor(state, :up)

        :down ->
          NavigationHelper.move_cursor(state, :down)

        :line_start ->
          NavigationHelper.move_cursor_line_start(state)

        :line_end ->
          NavigationHelper.move_cursor_line_end(state)

        :page_up ->
          NavigationHelper.move_cursor_page(state, :up)

        :page_down ->
          NavigationHelper.move_cursor_page(state, :down)

        :doc_start ->
          NavigationHelper.move_cursor_doc_start(state)

        :doc_end ->
          NavigationHelper.move_cursor_doc_end(state)
          # TODO: Add word movements
      end

    new_cursor_pos = moved_state.cursor_pos

    # Update selection: If no selection start, set it to original pos.
    # Always update selection end to the new cursor pos.
    selection_start = state.selection_start || original_cursor_pos

    final_state = %{
      moved_state
      | selection_start: selection_start,
        selection_end: new_cursor_pos
    }

    {:noreply, ensure_cursor_visible(final_state), nil}
  end

  def update({:select_all}, %State{} = state) do
    new_state = NavigationHelper.select_all(state)
    {:noreply, new_state, nil}
  end

  # --- Clipboard Operations ---
  def update({:copy}, %State{} = state) do
    # Check for selection first
    if elem(NavigationHelper.normalize_selection(state), 0) != nil do # Corrected check
      ClipboardHelper.copy_selection(state)
      {:noreply, state, nil} # No state change needed locally
    else
      {:noreply, state, nil} # No selection, do nothing
    end
  end

  def update({:cut}, %State{} = state) do
    # Check for selection first
    if elem(NavigationHelper.normalize_selection(state), 0) != nil do # Corrected check
      # Cut returns {new_state, cmd}, need to trigger change
      {new_state, cmd} = ClipboardHelper.cut_selection(state)
      trigger_on_change({:noreply, ensure_cursor_visible(new_state), cmd}, state)
    else
       {:noreply, state, nil} # No selection, do nothing
    end
  end

  def update({:paste}, %State{} = state) do
    {state, commands} = ClipboardHelper.paste(state)
    {state, commands}
  end

  # This is called when the clipboard content is received (e.g., from plugin)
  def update({:clipboard_content, content}, %State{} = state)
      when is_binary(content) do
    # Handle clipboard content arrival
    Logger.debug("Received clipboard content: #{inspect(content)}")
    # Insert the pasted content at the cursor
    {start_pos, end_pos} = if state.selection_start && state.selection_end do
      NavigationHelper.normalize_selection(state)
    else
      {state.cursor_pos, state.cursor_pos}
    end

    {new_value, _replaced} = TextHelper.replace_text_range(state.value, start_pos, end_pos, content)
    # Calculate new cursor position after insertion
    {start_row, start_col} = start_pos
    {new_row, new_col} = TextHelper.calculate_new_position(start_row, start_col, content)

    new_state = %{
      state
      | value: new_value,
        cursor_pos: {new_row, new_col},
        selection_start: nil, # Clear selection after paste
        selection_end: nil
    }

    if state.on_change, do: state.on_change.(new_value)
    new_state
  end

  # Ignore non-binary content
  def update({:clipboard_content, _}, %State{} = state) do
    {:noreply, state, nil}
  end

  # --- Focus Handling ---
  def update(:focus, %State{} = state) do
    {:noreply, %{state | focused: true}, nil}
  end

  def update(:blur, %State{} = state) do
    # Clear selection on blur
    {:noreply,
     %{state | focused: false, selection_start: nil, selection_end: nil}, nil}
  end

  # Handle Shift key state
  def update({:set_shift_held, held}, %State{} = state) do
     {:noreply, %{state | shift_held: held}, nil}
  end

  # Handle delete selection command (triggered by backspace/delete when selection exists)
  def update({:delete_selection, direction}, state) when direction in [:backward, :forward] do
    # Check if there is a selection before calling delete helper
    if elem(NavigationHelper.normalize_selection(state), 0) != nil do
      TextHelper.delete_selection(state)
    else
      # If somehow called without selection, do nothing.
      {:noreply, state}
    end
  end

  # Handle copy selection command
  def update({:copy_selection}, state) do
    # Check if there is a selection
    if elem(NavigationHelper.normalize_selection(state), 0) != nil do
      # Delegate to clipboard helper
      ClipboardHelper.copy_selection(state)
      {:noreply, state} # Indicate handled, but no state change here
    else
      {:noreply, state} # No selection, do nothing
    end
  end

  # --- Word Movements (Clears Selection) ---
  def update({:move_cursor_word_left}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor(state, :word_left)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  def update({:move_cursor_word_right}, %State{} = state) do
    new_state =
      NavigationHelper.move_cursor(state, :word_right)
      |> NavigationHelper.clear_selection()

    {:noreply, ensure_cursor_visible(new_state), nil}
  end

  # --- Movement Extending Selection ---
  def update({:move_cursor_select, direction}, %State{} = state)
      when direction in [:left, :right, :up, :down, :line_start, :line_end, :page_up, :page_down, :doc_start, :doc_end] do
    original_cursor_pos = state.cursor_pos

    # Determine the new cursor position based on direction
    moved_state =
      case direction do
        :left ->
          NavigationHelper.move_cursor(state, :left)

        :right ->
          NavigationHelper.move_cursor(state, :right)

        :up ->
          NavigationHelper.move_cursor(state, :up)

        :down ->
          NavigationHelper.move_cursor(state, :down)

        :line_start ->
          NavigationHelper.move_cursor_line_start(state)

        :line_end ->
          NavigationHelper.move_cursor_line_end(state)

        :page_up ->
          NavigationHelper.move_cursor_page(state, :up)

        :page_down ->
          NavigationHelper.move_cursor_page(state, :down)

        :doc_start ->
          NavigationHelper.move_cursor_doc_start(state)

        :doc_end ->
          NavigationHelper.move_cursor_doc_end(state)
      end

    new_cursor_pos = moved_state.cursor_pos

    # Update selection: If no selection start, set it to original pos.
    # Always update selection end to the new cursor pos.
    selection_start = state.selection_start || original_cursor_pos

    final_state = %{
      moved_state
      | selection_start: selection_start,
        selection_end: new_cursor_pos
    }

    {:noreply, ensure_cursor_visible(final_state), nil}
  end

  # --- Catch-all MUST BE LAST ---
  def update(msg, state) do
    Logger.warning("[MultiLineInput] Unhandled update message: #{inspect(msg)}")
    {:noreply, state, nil}
  end

  # Render the component
  @impl Raxol.UI.Components.Base.Component
  def render(state, _context) do
    # Calculate visible range
    start_row = state.scroll_offset |> elem(0)
    end_row = min(start_row + state.height - 1, length(state.lines) - 1)
    visible_lines = Enum.slice(state.lines, start_row..end_row)

    # Generate view elements for each visible line using the helper
    line_elements = Enum.with_index(visible_lines, start_row) |> Enum.map(fn {line, index} ->
      RenderHelper.render_line(index, line, state)
    end)

    # Handle placeholder text if value is empty and not focused
    placeholder_element =
      if state.value == "" and not state.focused and state.placeholder != "" do
        Raxol.View.Elements.label(
          content: state.placeholder,
          style: [color: state.style.placeholder_color]
        )
      else
        nil
      end

    # Prepare children first
    children = if placeholder_element != nil and visible_lines == [""] do
      [placeholder_element]
    else
      line_elements
    end

    # Flatten and remove nils *before* passing to the macro
    processed_children = children |> List.flatten() |> Enum.reject(&is_nil(&1))

    # Call the macro with the processed children list using a do block
    Raxol.View.Elements.column do
      processed_children
    end
  end

  # --- Internal Helpers ---

  # Ensures the cursor is visible within the viewport, adjusting scroll_offset.
  # This is a simplified version.
  defp ensure_cursor_visible(%State{} = state) do
    {cursor_row, _cursor_col} = state.cursor_pos
    {scroll_row, scroll_col} = state.scroll_offset
    height = state.height
    # width = state.width # Needed for horizontal scrolling

    new_scroll_row =
      cond do
        # Scroll up
        cursor_row < scroll_row -> cursor_row
        # Scroll down
        cursor_row >= scroll_row + height -> cursor_row - height + 1
        true -> scroll_row
      end

    # TODO: Implement horizontal scrolling adjustment based on cursor_col and scroll_col
    new_scroll_col = scroll_col

    # Update lines cache if needed (e.g., after text modification)
    # Re-calculate lines based on potentially new value
    # This might be inefficient if called too often. Consider optimizing.
    new_lines =
      TextHelper.split_into_lines(state.value, state.width, state.wrap)

    %{state | scroll_offset: {new_scroll_row, new_scroll_col}, lines: new_lines}
  end

  # Calls the on_change callback if defined and value changed by returning an event command
  defp trigger_on_change({:noreply, new_state, existing_cmd}, old_state) do
    # Check if value actually changed and a callback function exists
    if new_state.value != old_state.value and is_function(new_state.on_change, 1) do
      # Create the event to send to the parent
      change_event_cmd = {:component_event, new_state.id, {:change, new_state.value}}

      # Combine with any existing command (e.g., clipboard commands)
      # Assuming existing_cmd is nil or a list of commands
      new_cmd =
        case existing_cmd do
          nil -> [change_event_cmd]
          cmd when is_list(cmd) -> [change_event_cmd | cmd]
          # If existing_cmd is not a list, wrap it? Or assume it's singular?
          # For now, assume it's nil or a list. Handle errors later if needed.
          # Let's default to putting the change event first.
          single_cmd -> [change_event_cmd, single_cmd]
        end

      Logger.debug("Value changed for #{new_state.id}, queueing :change event.")
      {:noreply, new_state, new_cmd}
    else
      # No change or no callback, just pass through
      {:noreply, new_state, existing_cmd}
    end
  end

  # Pass through other results (e.g., {:reply, ...}, etc.)
  defp trigger_on_change(other, _old_state), do: other
end
