defmodule Mix.Tasks.Raxol.Visual do
  @moduledoc """
  Visual regression testing for Raxol UI components.

  This task captures visual snapshots of UI components and compares them
  against baseline images to detect visual regressions.

  ## Usage

      mix raxol.visual [command] [options]
      
  ## Commands

    * `capture` - Capture new baseline screenshots
    * `test` - Run visual regression tests
    * `update` - Update baseline images with current renders
    * `clean` - Remove old visual test artifacts

  ## Options

    * `--component` - Test specific component (e.g., button, table, progress)
    * `--theme` - Test specific theme (default: all themes)
    * `--size` - Test specific size (e.g., 80x24, 120x40)
    * `--format` - Output format: ascii, ansi, html (default: ansi)
    * `--diff-threshold` - Pixel difference threshold (0.0-1.0, default: 0.01)
    * `--verbose` - Show detailed output

  ## Examples

      # Capture baseline images for all components
      mix raxol.visual capture
      
      # Test all components for regressions
      mix raxol.visual test
      
      # Test specific component
      mix raxol.visual test --component button
      
      # Update baselines after intentional changes
      mix raxol.visual update --component progress
      
  ## Directory Structure

      test/visual/
      ‚îú‚îÄ‚îÄ baselines/          # Baseline images
      ‚îÇ   ‚îú‚îÄ‚îÄ button/
      ‚îÇ   ‚îú‚îÄ‚îÄ table/
      ‚îÇ   ‚îî‚îÄ‚îÄ progress/
      ‚îú‚îÄ‚îÄ current/            # Current test renders
      ‚îú‚îÄ‚îÄ diffs/              # Difference images
      ‚îî‚îÄ‚îÄ reports/            # Test reports
  """

  use Mix.Task

  @shortdoc "Visual regression testing for UI components"

  # Component test scenarios
  @test_components %{
    "button" => [
      {%{text: "Click Me", style: :primary}, "primary"},
      {%{text: "Cancel", style: :secondary}, "secondary"},
      {%{text: "Delete", style: :danger}, "danger"},
      {%{text: "Disabled", style: :primary, disabled: true}, "disabled"}
    ],
    "table" => [
      {%{
         headers: ["Name", "Age", "City"],
         rows: [["Alice", "25", "NYC"], ["Bob", "30", "LA"]]
       }, "simple"},
      {%{
         headers: ["ID", "Status", "Progress"],
         rows: [["001", "Active", "75%"], ["002", "Pending", "20%"]],
         styling: :striped
       }, "striped"}
    ],
    "progress" => [
      {%{value: 0, max: 100}, "empty"},
      {%{value: 50, max: 100}, "half"},
      {%{value: 100, max: 100}, "full"},
      {%{value: 75, max: 100, style: :success}, "success"}
    ],
    "input" => [
      {%{placeholder: "Enter text...", value: ""}, "empty"},
      {%{placeholder: "Enter text...", value: "Hello World"}, "filled"},
      {%{placeholder: "Enter text...", value: "", disabled: true}, "disabled"}
    ]
  }

  @test_themes ["default", "dark", "high_contrast"]
  @test_sizes [{80, 24}, {120, 40}]

  @impl Mix.Task
  def run([]), do: run(["test"])

  def run([command | args]) do
    {opts, _} =
      OptionParser.parse!(args,
        strict: [
          component: :string,
          theme: :string,
          size: :string,
          format: :string,
          diff_threshold: :float,
          verbose: :boolean
        ]
      )

    case command do
      "capture" ->
        run_capture(opts)

      "test" ->
        run_test(opts)

      "update" ->
        run_update(opts)

      "clean" ->
        run_clean(opts)

      _ ->
        Mix.Shell.IO.error("Unknown command: #{command}")
        Mix.Shell.IO.info("Available commands: capture, test, update, clean")
        System.halt(1)
    end
  end

  defp run_capture(opts) do
    Mix.Shell.IO.info("üì∏ Capturing visual baselines...")

    ensure_directories()
    components = get_components_to_test(opts)
    themes = get_themes_to_test(opts)
    sizes = get_sizes_to_test(opts)

    total = length(components) * length(themes) * length(sizes)
    Mix.Shell.IO.info("Will capture #{total} baseline images")

    capture_count = 0

    for component <- components,
        theme <- themes,
        size <- sizes do
      scenarios = @test_components[component]

      for {props, scenario_name} <- scenarios do
        capture_count = capture_count + 1

        if opts[:verbose] do
          Mix.Shell.IO.info(
            "Capturing #{component}/#{scenario_name} (#{theme}, #{elem(size, 0)}x#{elem(size, 1)}) [#{capture_count}/#{total}]"
          )
        end

        image_data = render_component(component, props, theme, size, opts)

        baseline_path =
          baseline_path(
            component,
            scenario_name,
            theme,
            size,
            opts[:format] || "ansi"
          )

        File.write!(baseline_path, image_data)
      end
    end

    Mix.Shell.IO.info("‚úÖ Captured #{capture_count} baseline images")
  end

  defp run_test(opts) do
    Mix.Shell.IO.info("üîç Running visual regression tests...")

    ensure_directories()
    components = get_components_to_test(opts)
    themes = get_themes_to_test(opts)
    sizes = get_sizes_to_test(opts)
    threshold = opts[:diff_threshold] || 0.01

    results = 
      for component <- components,
          theme <- themes,
          size <- sizes,
          {props, scenario_name} <- @test_components[component] do
        test_component_scenario(
          component,
          scenario_name,
          props,
          theme,
          size,
          threshold,
          opts
        )
      end

    # Generate report
    generate_test_report(results, opts)

    failed_count = Enum.count(results, &(&1.status == :failed))

    if failed_count > 0 do
      Mix.Shell.IO.error("‚ùå #{failed_count} visual tests failed")
      System.halt(1)
    else
      Mix.Shell.IO.info("‚úÖ All visual tests passed")
    end
  end

  defp run_update(opts) do
    Mix.Shell.IO.info("üîÑ Updating visual baselines...")

    # Capture new baselines (same as capture but overwrites)
    run_capture(opts)

    Mix.Shell.IO.info("‚úÖ Visual baselines updated")
  end

  defp run_clean(_opts) do
    Mix.Shell.IO.info("üßπ Cleaning visual test artifacts...")

    paths_to_clean = [
      "test/visual/current",
      "test/visual/diffs",
      "test/visual/reports"
    ]

    for path <- paths_to_clean do
      if File.exists?(path) do
        File.rm_rf!(path)
        Mix.Shell.IO.info("Cleaned #{path}")
      end
    end

    Mix.Shell.IO.info("‚úÖ Visual test artifacts cleaned")
  end

  # Helper functions

  defp ensure_directories do
    dirs = [
      "test/visual/baselines",
      "test/visual/current",
      "test/visual/diffs",
      "test/visual/reports"
    ]

    for dir <- dirs do
      File.mkdir_p!(dir)
    end
  end

  defp get_components_to_test(opts) do
    case opts[:component] do
      nil -> Map.keys(@test_components)
      component -> [component]
    end
  end

  defp get_themes_to_test(opts) do
    case opts[:theme] do
      nil -> @test_themes
      theme -> [theme]
    end
  end

  defp get_sizes_to_test(opts) do
    case opts[:size] do
      nil ->
        @test_sizes

      size_str ->
        [w, h] = String.split(size_str, "x") |> Enum.map(&String.to_integer/1)
        [{w, h}]
    end
  end

  defp render_component(component, props, theme, {width, height}, opts) do
    # Mock rendering - in real implementation this would render the component
    format = opts[:format] || "ansi"

    case format do
      "ascii" -> render_ascii_component(component, props, theme, width, height)
      "ansi" -> render_ansi_component(component, props, theme, width, height)
      "html" -> render_html_component(component, props, theme, width, height)
    end
  end

  defp render_ascii_component(component, props, _theme, width, height) do
    # Simple ASCII rendering for demonstration
    header = "Component: #{component}"
    props_line = "Props: #{inspect(props)}"
    border = String.duplicate("-", width)

    content = [
      border,
      pad_line(header, width),
      pad_line(props_line, width),
      border
    ]

    # Fill remaining height
    remaining = height - length(content)
    padding = for _ <- 1..max(0, remaining), do: pad_line("", width)

    (content ++ padding) |> Enum.join("\n")
  end

  defp render_ansi_component(component, props, theme, width, height) do
    # ANSI colored rendering
    color_code =
      case theme do
        # White on black
        "dark" -> "\e[37;40m"
        # Yellow on blue
        "high_contrast" -> "\e[33;44m"
        # Green on default
        _ -> "\e[32;49m"
      end

    reset = "\e[0m"
    header = "#{color_code}Component: #{component}#{reset}"
    props_line = "Props: #{inspect(props)}"
    border = String.duplicate("=", width)

    content = [
      border,
      pad_line(header, width),
      pad_line(props_line, width),
      border
    ]

    # Fill remaining height
    remaining = height - length(content)
    padding = for _ <- 1..max(0, remaining), do: pad_line("", width)

    (content ++ padding) |> Enum.join("\n")
  end

  defp render_html_component(component, props, theme, width, height) do
    # HTML rendering for web display
    style =
      case theme do
        "dark" -> "background: #1a1a1a; color: #ffffff;"
        "high_contrast" -> "background: #000000; color: #ffff00;"
        _ -> "background: #ffffff; color: #000000;"
      end

    """
    <div style="#{style} width: #{width * 8}px; height: #{height * 16}px; font-family: monospace; padding: 8px;">
      <h3>Component: #{component}</h3>
      <pre>#{inspect(props, pretty: true)}</pre>
    </div>
    """
  end

  defp pad_line(text, width) do
    text
    |> String.slice(0, width)
    |> String.pad_trailing(width)
  end

  defp baseline_path(component, scenario, theme, {width, height}, format) do
    filename = "#{scenario}_#{theme}_#{width}x#{height}.#{format}"
    Path.join(["test", "visual", "baselines", component, filename])
  end

  defp current_path(component, scenario, theme, {width, height}, format) do
    filename = "#{scenario}_#{theme}_#{width}x#{height}.#{format}"
    Path.join(["test", "visual", "current", component, filename])
  end

  defp test_component_scenario(
         component,
         scenario,
         props,
         theme,
         size,
         threshold,
         opts
       ) do
    # Render current version
    current_data = render_component(component, props, theme, size, opts)

    # Save current render
    current_path =
      current_path(component, scenario, theme, size, opts[:format] || "ansi")

    File.mkdir_p!(Path.dirname(current_path))
    File.write!(current_path, current_data)

    # Load baseline
    baseline_path =
      baseline_path(component, scenario, theme, size, opts[:format] || "ansi")

    if File.exists?(baseline_path) do
      baseline_data = File.read!(baseline_path)

      # Compare images
      difference = calculate_difference(baseline_data, current_data)

      status = if difference > threshold, do: :failed, else: :passed

      if opts[:verbose] and status == :failed do
        Mix.Shell.IO.info(
          "‚ùå #{component}/#{scenario} (#{theme}) diff: #{Float.round(difference, 4)}"
        )
      end

      %{
        component: component,
        scenario: scenario,
        theme: theme,
        size: size,
        status: status,
        difference: difference,
        threshold: threshold
      }
    else
      IO.warn(
        "‚ö†Ô∏è  No baseline for #{component}/#{scenario} (#{theme})"
      )

      %{
        component: component,
        scenario: scenario,
        theme: theme,
        size: size,
        status: :no_baseline,
        difference: nil,
        threshold: threshold
      }
    end
  end

  defp calculate_difference(baseline, current) do
    # Simple string difference - in production use actual image comparison
    if baseline == current do
      0.0
    else
      # Calculate Levenshtein distance ratio
      baseline_len = String.length(baseline)
      current_len = String.length(current)
      max_len = max(baseline_len, current_len)

      if max_len == 0 do
        0.0
      else
        distance = String.jaro_distance(baseline, current)
        1.0 - distance
      end
    end
  end

  defp generate_test_report(results, _opts) do
    report_path = Path.join(["test", "visual", "reports", "report.html"])

    passed = Enum.count(results, &(&1.status == :passed))
    failed = Enum.count(results, &(&1.status == :failed))
    no_baseline = Enum.count(results, &(&1.status == :no_baseline))
    total = length(results)

    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
      <title>Visual Regression Test Report</title>
      <style>
        body { font-family: sans-serif; margin: 20px; }
        .summary { background: #f5f5f5; padding: 15px; border-radius: 5px; }
        .passed { color: green; }
        .failed { color: red; }
        .no-baseline { color: orange; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
      </style>
    </head>
    <body>
      <h1>Visual Regression Test Report</h1>
      
      <div class="summary">
        <h2>Summary</h2>
        <p>Total Tests: #{total}</p>
        <p class="passed">‚úÖ Passed: #{passed}</p>
        <p class="failed">‚ùå Failed: #{failed}</p>  
        <p class="no-baseline">‚ö†Ô∏è No Baseline: #{no_baseline}</p>
      </div>
      
      <h2>Detailed Results</h2>
      <table>
        <tr>
          <th>Component</th>
          <th>Scenario</th>
          <th>Theme</th>
          <th>Size</th>
          <th>Status</th>
          <th>Difference</th>
        </tr>
        #{Enum.map_join(results, "\n", &format_result_row/1)}
      </table>
      
      <p><small>Generated at #{DateTime.now!("Etc/UTC") |> DateTime.to_string()}</small></p>
    </body>
    </html>
    """

    File.write!(report_path, html_content)
    Mix.Shell.IO.info("üìä Report saved to #{report_path}")
  end

  defp format_result_row(result) do
    {status_class, status_text} =
      case result.status do
        :passed -> {"passed", "‚úÖ Passed"}
        :failed -> {"failed", "‚ùå Failed"}
        :no_baseline -> {"no-baseline", "‚ö†Ô∏è No Baseline"}
      end

    diff_text =
      if result.difference do
        Float.round(result.difference, 4)
      else
        "N/A"
      end

    {w, h} = result.size

    """
    <tr class="#{status_class}">
      <td>#{result.component}</td>
      <td>#{result.scenario}</td>
      <td>#{result.theme}</td>
      <td>#{w}x#{h}</td>
      <td>#{status_text}</td>
      <td>#{diff_text}</td>
    </tr>
    """
  end
end
