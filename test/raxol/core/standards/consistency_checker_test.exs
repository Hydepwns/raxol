defmodule Raxol.Core.Standards.ConsistencyCheckerTest do
  use ExUnit.Case, async: true

  alias Raxol.Core.Standards.ConsistencyChecker

  describe "check_file/1" do
    test "detects missing moduledoc" do
      content = """
      defmodule TestModule do
        def hello, do: :world
      end
      """

      File.write!("test_no_moduledoc.ex", content)
      
      assert {:ok, issues} = ConsistencyChecker.check_file("test_no_moduledoc.ex")
      assert Enum.any?(issues, fn issue ->
        issue.type == :missing_moduledoc
      end)

      File.rm!("test_no_moduledoc.ex")
    end

    test "detects missing function documentation" do
      content = """
      defmodule TestModule do
        @moduledoc "Test module"
        
        def public_function(arg) do
          arg
        end
      end
      """

      File.write!("test_no_doc.ex", content)
      
      assert {:ok, issues} = ConsistencyChecker.check_file("test_no_doc.ex")
      assert Enum.any?(issues, fn issue ->
        issue.type == :missing_doc && issue.message =~ "public_function/1"
      end)

      File.rm!("test_no_doc.ex")
    end

    test "detects invalid function naming" do
      content = """
      defmodule TestModule do
        @moduledoc "Test module"
        
        @doc "Test function"
        def myFunction do
          :ok
        end
      end
      """

      File.write!("test_bad_naming.ex", content)
      
      assert {:ok, issues} = ConsistencyChecker.check_file("test_bad_naming.ex")
      assert Enum.any?(issues, fn issue ->
        issue.type == :naming_convention && issue.message =~ "uppercase"
      end)

      File.rm!("test_bad_naming.ex")
    end

    test "detects non-standard error handling" do
      content = """
      defmodule TestModule do
        @moduledoc "Test module"
        
        @doc "Returns bare atom"
        def bad_error_handling do
          :error
        end
      end
      """

      File.write!("test_bad_errors.ex", content)
      
      assert {:ok, _issues} = ConsistencyChecker.check_file("test_bad_errors.ex")
      
      # Note: This specific check might not be caught by the current implementation
      # but demonstrates the test structure
      
      File.rm!("test_bad_errors.ex")
    end

    test "detects formatting issues" do
      content = """
      defmodule TestModule do
        @moduledoc "Test module"
        
        @doc "Long line function"
        def very_long_function_name_that_exceeds_the_recommended_character_limit_of_one_hundred_and_twenty_characters_per_line do
          :ok
        end
      end
      """

      File.write!("test_long_lines.ex", content)
      
      assert {:ok, issues} = ConsistencyChecker.check_file("test_long_lines.ex")
      assert Enum.any?(issues, fn issue ->
        issue.type == :formatting && issue.message =~ "exceeds 120 characters"
      end)

      File.rm!("test_long_lines.ex")
    end

    test "accepts well-formatted code" do
      content = """
      defmodule TestModule do
        @moduledoc \"\"\"
        Well-documented test module.
        \"\"\"

        @doc \"\"\"
        Says hello.
        \"\"\"
        @spec hello() :: :world
        def hello do
          :world
        end
      end
      """

      File.write!("test_good_code.ex", content)
      
      assert {:ok, issues} = ConsistencyChecker.check_file("test_good_code.ex")
      
      # Should have minimal issues
      assert length(issues) <= 1  # Allow for module name mismatch
      
      File.rm!("test_good_code.ex")
    end
  end

  describe "check_directory/1" do
    setup do
      # Create test directory structure
      File.mkdir_p!("test_consistency_check")
      
      on_exit(fn ->
        File.rm_rf!("test_consistency_check")
      end)
      
      :ok
    end

    test "analyzes multiple files in directory" do
      # Create test files
      File.write!("test_consistency_check/file1.ex", """
      defmodule File1 do
        @moduledoc "File 1"
        def test, do: :ok
      end
      """)

      File.write!("test_consistency_check/file2.ex", """
      defmodule File2 do
        def test, do: :ok
      end
      """)

      assert {:ok, report} = ConsistencyChecker.check_directory("test_consistency_check")
      
      assert report.total_files == 2
      assert length(report.issues) > 0
      assert Map.has_key?(report.summary, :missing_moduledoc)
    end

    test "handles nested directories" do
      File.mkdir_p!("test_consistency_check/nested")
      
      File.write!("test_consistency_check/nested/nested_file.ex", """
      defmodule NestedFile do
        @moduledoc "Nested file"
        def test, do: :ok
      end
      """)

      assert {:ok, report} = ConsistencyChecker.check_directory("test_consistency_check")
      assert report.total_files >= 1
    end
  end

  describe "generate_report/1" do
    test "formats report correctly" do
      report = %{
        total_files: 10,
        issues: [
          %{
            file: "test.ex",
            line: 5,
            type: :missing_doc,
            message: "Function test/1 missing documentation",
            severity: :warning
          }
        ],
        summary: %{
          missing_doc: 1
        }
      }

      output = ConsistencyChecker.generate_report(report)
      
      assert output =~ "Total files analyzed: 10"
      assert output =~ "Total issues found: 1"
      assert output =~ "Missing doc"
      assert output =~ "test.ex"
      assert output =~ "Line 5"
    end

    test "provides recommendations based on issues" do
      report = %{
        total_files: 5,
        issues: [
          %{file: "a.ex", line: 1, type: :missing_moduledoc, message: "Missing moduledoc", severity: :warning},
          %{file: "b.ex", line: 10, type: :missing_doc, message: "Missing doc", severity: :warning}
        ],
        summary: %{
          missing_moduledoc: 1,
          missing_doc: 1
        }
      }

      output = ConsistencyChecker.generate_report(report)
      
      assert output =~ "Add @moduledoc documentation"
      assert output =~ "Add @doc documentation"
    end
  end
end