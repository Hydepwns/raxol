defmodule Raxol.Terminal.Commands.CSIHandlersTest do
  # async: true if no shared state mutation beyond emulator instance
  use ExUnit.Case, async: true

  alias Raxol.Terminal.Commands.CSIHandlers
  alias Raxol.Terminal.Emulator
  alias Raxol.Terminal.Cursor.Manager, as: CursorManager
  # For creating initial style
  alias Raxol.Terminal.ANSI.TextFormatting
  # For setup if needed
  alias Raxol.Terminal.ScreenBuffer

  setup do
    # Basic emulator setup for tests
    emulator = Emulator.new(80, 24)
    # Ensure saved_cursor is initially nil as per recent Emulator.ex changes
    emulator = %{emulator | saved_cursor: nil}
    {:ok, emulator: emulator}
  end

  defp unwrap_ok({:ok, value}), do: value
  defp unwrap_ok({:error, _reason, value}), do: value
  defp unwrap_ok(value) when is_map(value), do: value

  describe "handle_s/2 (Save Cursor Position - SCP)" do
    test "saves the current cursor state (position and style)", %{
      emulator: emulator
    } do
      # Modify current cursor state
      current_cursor_state = %CursorManager{
        # row 5, col 10
        position: {5, 10},
        # Example style
        style: :steady_bar,
        state: :visible
      }

      emulator_with_cursor = %{emulator | cursor: current_cursor_state}

      # Apply SCP
      result_emulator = unwrap_ok(CSIHandlers.handle_s(emulator_with_cursor, []))

      # Verify that saved_cursor now holds the current_cursor_state
      assert result_emulator.saved_cursor == current_cursor_state
      # Verify current cursor is unchanged by SCP itself
      assert result_emulator.cursor == current_cursor_state
    end
  end

  describe "handle_u/2 (Restore Cursor Position - RCP)" do
    test "restores the cursor state from saved_cursor", %{emulator: emulator} do
      # Define a saved cursor state
      saved_cursor_state = %CursorManager{
        position: {3, 7},
        style: :blink_underline,
        state: :hidden
      }

      emulator_with_saved = %{emulator | saved_cursor: saved_cursor_state}

      # Current cursor is different
      current_cursor_state = %CursorManager{
        position: {0, 0},
        style: :steady_block,
        state: :visible
      }

      emulator_to_restore = %{
        emulator_with_saved
        | cursor: current_cursor_state
      }

      # Apply RCP
      result_emulator = unwrap_ok(CSIHandlers.handle_u(emulator_to_restore, []))

      # Verify that current cursor is now the saved_cursor_state
      assert result_emulator.cursor == saved_cursor_state

      # Verify saved_cursor itself is not cleared by RCP (as per typical terminal behavior)
      assert result_emulator.saved_cursor == saved_cursor_state
    end

    test "does nothing if saved_cursor is nil", %{emulator: emulator} do
      initial_cursor_state = emulator.cursor
      # Ensure saved_cursor is nil (should be from setup)
      assert emulator.saved_cursor == nil

      # Apply RCP
      result_emulator = unwrap_ok(CSIHandlers.handle_u(emulator, []))

      # Verify that emulator state (and cursor) is unchanged
      assert result_emulator == emulator
      assert result_emulator.cursor == initial_cursor_state
    end
  end

  describe "handle_q_deccusr/2 (Set Cursor Style)" do
    test "sets cursor style to blink_block (0 or 1 or default)", %{
      emulator: emulator
    } do
      res_0 = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [0]))
      assert res_0.cursor.style == :blink_block

      res_1 = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [1]))
      assert res_1.cursor.style == :blink_block

      # Default param is 0
      res_default = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, []))
      assert res_default.cursor.style == :blink_block
    end

    test "sets cursor style to steady_block (2)", %{emulator: emulator} do
      result = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [2]))
      assert result.cursor.style == :steady_block
    end

    test "sets cursor style to blink_underline (3)", %{emulator: emulator} do
      result = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [3]))
      assert result.cursor.style == :blink_underline
    end

    test "sets cursor style to steady_underline (4)", %{emulator: emulator} do
      result = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [4]))
      assert result.cursor.style == :steady_underline
    end

    test "sets cursor style to blink_bar (5)", %{emulator: emulator} do
      result = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [5]))
      assert result.cursor.style == :blink_bar
    end

    test "sets cursor style to steady_bar (6)", %{emulator: emulator} do
      result = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [6]))
      assert result.cursor.style == :steady_bar
    end

    test "handles invalid style code, keeps current style", %{
      emulator: emulator
    } do
      # Default from CursorManager.new()
      initial_style = emulator.cursor.style
      # Invalid code
      result = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, [99]))
      assert result.cursor.style == initial_style
    end

    test "handles invalid parameter type, defaults to blink_block", %{
      emulator: emulator
    } do
      # ParameterValidation.get_valid_non_neg_param converts non-integer to default (0)
      result = unwrap_ok(CSIHandlers.handle_q_deccusr(emulator, ["invalid"]))
      assert result.cursor.style == :blink_block
    end
  end

  describe "handle_scs/3 (Designate Character Set - Simplified)" do
    # Test based on the current simplified implementation in CSIHandlers.ex
    # which uses integer codes and only affects charset_state.active

    test "sets G0 to ASCII with param \"0\" (actually \"?0\"), final_byte '('", %{emulator: emulator} do
      # Original test expected :us_ascii for active. Param "0" -> charset_code ?0.
      # CharacterSets.charset_code_to_module(?0) maps to CharacterSets.DEC (for DEC Special Graphics).
      # final_byte ?( targets :g0.
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "0", ?()))
      assert result.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.DEC
    end

    test "sets G1 to ASCII with param \"0\" (actually \"?0\"), final_byte ')'", %{emulator: emulator} do
      # Original test expected :us_ascii for active. Param "0" -> charset_code ?0.
      # CharacterSets.charset_code_to_module(?0) maps to CharacterSets.DEC.
      # final_byte ?) targets :g1.
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "0", '?'))
      assert result.charset_state.g1 == Raxol.Terminal.ANSI.CharacterSets.DEC
    end

    test "sets G0 with param \"1\" (actually \"?1\"), final_byte '('", %{
      emulator: emulator
    } do
      # Param "1" -> charset_code ?1.
      # CharacterSets.charset_code_to_module(?1) is currently nil, so g0 should be unchanged.
      initial_g0 = emulator.charset_state.g0 # Get initial state from emulator
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "1", ?()))
      assert result.charset_state.g0 == initial_g0 # Or specific module if ?1 is mapped
    end

    test "sets G0 with param \"16\" (actually \"?1\"), final_byte '('", %{
      emulator: emulator
    } do
      # Param "16" -> charset_code ?1 (due to String.at(..., 0)).
      # CharacterSets.charset_code_to_module(?1) is currently nil, so g0 should be unchanged.
      initial_g0 = emulator.charset_state.g0 # Get initial state from emulator
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "16", ?()))
      assert result.charset_state.g0 == initial_g0 # Or specific module if ?1 is mapped
    end

    test "designates G0 with specific char codes, final_byte '('", %{
      emulator: emulator
    } do
      # Test for :dec_technical using its actual code (e.g., ?>, assuming it maps to CharacterSets.DEC for now)
      # If CharacterSets.charset_code_to_module(?>) returns CharacterSets.DEC
      technical_code_char = ?> # Assuming this is the code for DECTechnical
      result_technical = unwrap_ok(CSIHandlers.handle_scs(emulator, <<technical_code_char>>, ?()))
      assert result_technical.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.DEC

      # Test for :portuguese using its actual code (e.g., ?I or ?")
      # Use the state of the original emulator before this specific call
      initial_g0_for_portuguese_call = emulator.charset_state.g0
      portuguese_char_code = ?\" # Example code for Portuguese
      # Perform the call on the original emulator
      result_portuguese = unwrap_ok(CSIHandlers.handle_scs(emulator, <<portuguese_char_code>>, ?()))
      # Assuming ?\" maps to nil or doesn't change G0 from its state in the original 'emulator'
      assert result_portuguese.charset_state.g0 == initial_g0_for_portuguese_call

      # Test for 'A' -> UK. This call is also on the original emulator.
      result_A = unwrap_ok(CSIHandlers.handle_scs(emulator, "A", ?()))
      assert result_A.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.UK
    end

    test "handles unknown code/final_byte combination gracefully", %{
      emulator: emulator
    } do
      initial_charset_state = emulator.charset_state
      # Unknown code ("99" -> charset_code ?9 -> module nil)
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "99", ?()))
      assert result.charset_state == initial_charset_state
      # Should return emulator unchanged if charset module is nil
      assert result == emulator # The handler returns error tuple, unwrap_ok gives emulator

      # Unknown final_byte (module is ASCII for "B", but final_byte ?X is invalid)
      result2 = unwrap_ok(CSIHandlers.handle_scs(emulator, "B", ?X))
      assert result2.charset_state == initial_charset_state
      assert result2 == emulator
    end

    test "handles empty params (defaults to code \"B\"), final_byte '(', sets G0 to ASCII", %{emulator: emulator} do
      # Empty param defaults to "B" -> charset_code ?B -> ASCII module.
      # final_byte ?( targets :g0.
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "", ?()))
      assert result.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.ASCII
    end

    test "sets G0 to a specific character set using single char param, final_byte '('", %{emulator: emulator} do
      # Example from https://vt100.net/docs/vt510-rm/SCS.html: designate Portuguese as G0: ESC ( % 6 ST (param: %6, final_byte: ()
      # Our handler gets param: "%6", final_byte: (
      # We need to handle single char param "R" for DEC Technical and "%6" for Portuguese etc.
      # For this test, let's use "R" for DEC Technical
      technical_code_char = ?R
      result_technical = unwrap_ok(CSIHandlers.handle_scs(emulator, <<technical_code_char>>, ?()))
      assert emulator.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.DECTechnical
      assert result_technical == :ok

      # And Portuguese "%6"
      portuguese_char_code = ?6 # Part of the "%6" sequence, assuming the '%' is handled upstream or is part of the param.
                                 # The CSI handler for SCS might only get param: "%6" if it's part of a two-char sequence like "%6".
                                 # Let's assume for now param is the character that denotes the set e.g. '6' for Portuguese if part of '%6'
                                 # Or the direct single character like 'R'
      # For SCS, param is single char for some, or two for others (ignored first char of two like '%')
      # Let's test with just "A" for US ASCII
      result_A = unwrap_ok(CSIHandlers.handle_scs(emulator, "A", ?())) # Should set G0 to US ASCII
      assert emulator.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.USASCII
      assert result_A == :ok

      # Test with Portuguese, assuming param comes as "6" (from "%6")
      portuguese_char_code = ?6
      result_portuguese = unwrap_ok(CSIHandlers.handle_scs(emulator, <<portuguese_char_code>>, ?()))
      assert emulator.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.Portuguese
      assert result_portuguese == :ok
    end

    test "returns {:error, :unknown_character_set} for unknown character set code with final_byte '('", %{
      emulator: emulator
    } do
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "99", ?())) # "99" is not a valid param
      # The spec says invalid SCS sequences are ignored. So it should be :ok and no change.
      # However, our current CharacterSets.charset_code_to_module raises for unknown.
      # Let's assume for now it should return an error if we can't map it.
      # Or, more likely, it's ignored, so :ok and no change to charset.
      # Current behavior based on charset_code_to_module will be an error or exception.
      # Let's check current CharacterSets.charset_code_to_module contract.
      # It raises an error if not found. So this test should probably expect that, or the handler should catch it.
      # For now, let's assume the handler should return an error tuple.
      # This needs clarification based on how strictly we follow "ignored".
      # Let's test the "ignored" behavior: it should be :ok and no change.
      original_g0 = emulator.charset_state.g0
      result = CSIHandlers.handle_scs(emulator, "99", ?()) # "99" is not a valid param
      assert result == :ok
      assert emulator.charset_state.g0 == original_g0
    end

    # final_byte '(' targets :g0, final_byte ')' targets :g1, final_byte '*' targets :g2, final_byte '+' targets :g3
    # According to https://vt100.net/docs/vt510-rm/SCS.html
    # "If you omit P S , the terminal selects character set G0." - This implies empty param "" should default to "0" or "B" (US ASCII)
    # Let's assume empty param means US ASCII ("B") for G0 if final_byte is '('.
    test "sets G0 to US ASCII (default) with empty param, final_byte '('", %{emulator: emulator} do
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "", ?()))
      assert emulator.charset_state.g0 == Raxol.Terminal.ANSI.CharacterSets.ASCII
      assert result == :ok
    end
  end

  describe "handle_r/2 (Set Scrolling Region - DECSTBM)" do
    setup %{emulator: emulator} do
      # Buffer is 80x24. Height is 24.
      # Scroll region is 0-based internally {top_line_idx, bottom_line_idx}
      {:ok,
       emulator: emulator,
       buffer_height:
         ScreenBuffer.get_height(Emulator.get_active_buffer(emulator))}
    end

    test "sets a valid scrolling region and moves cursor to home", %{
      emulator: emulator
    } do
      # Params are 1-based: [top, bottom]. e.g. lines 5 to 10.
      # Internally: {4, 9}
      result = unwrap_ok(CSIHandlers.handle_r(emulator, [5, 10]))
      assert result.scroll_region == {4, 9}
      assert CursorManager.get_position(result) == {0, 0}
    end

    test "resets to full screen if no parameters and moves cursor to home", %{
      emulator: emulator
    } do
      # Set a region first to ensure it's cleared
      emulator_with_region = %{emulator | scroll_region: {5, 10}}
      result = unwrap_ok(CSIHandlers.handle_r(emulator_with_region, []))
      assert result.scroll_region == nil
      assert CursorManager.get_position(result) == {0, 0}
    end

    test "resets to full screen if top param only and moves cursor to home", %{
      emulator: emulator,
      buffer_height: bh
    } do
      # Params: [top]. Bottom defaults to buffer_height.
      # e.g., [5] -> top=5 (0-based 4), bottom=24 (0-based 23)
      result = unwrap_ok(CSIHandlers.handle_r(emulator, [5]))
      # {4, 23} for 24 line buffer
      assert result.scroll_region == {4, bh - 1}
      assert CursorManager.get_position(result) == {0, 0}
    end

    test "resets to full screen if bottom param only (invalid, top defaults to 1)",
         %{emulator: emulator, buffer_height: bh} do
      # Params: [nil, bottom]. Top defaults to 1.
      # Effectively [1, bottom_param]
      # ParameterValidation.get_valid_param(params, 0, 1, ...) will make top=1
      result = unwrap_ok(CSIHandlers.handle_r(emulator, [nil, 10]))
      # {0, 9} for [1, 10]
      assert result.scroll_region == {0, 9}
      assert CursorManager.get_position(result) == {0, 0}
    end

    test "resets to full screen if top >= bottom and moves cursor to home", %{
      emulator: emulator
    } do
      # Params [10, 5] -> top=10, bottom=5. This is invalid.
      result = unwrap_ok(CSIHandlers.handle_r(emulator, [10, 5]))
      assert result.scroll_region == nil
      assert CursorManager.get_position(result) == {0, 0}

      # Params [5, 5] -> top=5, bottom=5. This is invalid.
      result2 = unwrap_ok(CSIHandlers.handle_r(emulator, [5, 5]))
      assert result2.scroll_region == nil
      assert CursorManager.get_position(result2) == {0, 0}
    end

    test "handles region spanning full height correctly", %{
      emulator: emulator,
      buffer_height: bh
    } do
      # 1-based full height
      result = unwrap_ok(CSIHandlers.handle_r(emulator, [1, bh]))
      assert result.scroll_region == {0, bh - 1}
      assert CursorManager.get_position(result) == {0, 0}
    end

    test "clamps parameters to buffer height", %{
      emulator: emulator,
      buffer_height: bh
    } do
      # Params [5, 100] -> top=5, bottom clamped to buffer_height (24 for 80x24)
      # Internally {4, 23}
      result = unwrap_ok(CSIHandlers.handle_r(emulator, [5, bh + 10]))
      assert result.scroll_region == {4, bh - 1}
      assert CursorManager.get_position(result) == {0, 0}

      # Params [-5, 10] -> top clamped to 1, bottom = 10
      # Internally {0, 9}
      result2 = unwrap_ok(CSIHandlers.handle_r(emulator, [-5, 10]))
      assert result2.scroll_region == {0, 9}
      assert CursorManager.get_position(result2) == {0, 0}
    end
  end

  describe "error/result tuple propagation" do
    test "handle_u/2 returns error tuple when no saved_cursor, and only emulator is passed to UI",
         %{emulator: emulator} do
      # saved_cursor is nil by default
      result = unwrap_ok(CSIHandlers.handle_u(emulator, []))
      assert {:error, :no_saved_cursor, returned_emulator} = result
      # Simulate executor/UI unwrapping
      assert returned_emulator == emulator
      # Only the emulator struct would be passed to the renderer/UI
      assert is_map(returned_emulator)

      refute Map.has_key?(returned_emulator, :__struct__) and
               returned_emulator.__struct__ != Raxol.Terminal.Emulator
    end

    test "handle_scs/3 returns error tuple for invalid charset designation, and only emulator is passed to UI",
         %{emulator: emulator} do
      # Use invalid charset_param_str and final_byte
      result = unwrap_ok(CSIHandlers.handle_scs(emulator, "", ?Z))
      assert {:error, :invalid_charset_designation, returned_emulator} = result
      # Simulate executor/UI unwrapping
      assert returned_emulator == emulator
      # Only the emulator struct would be passed to the renderer/UI
      assert is_map(returned_emulator)

      refute Map.has_key?(returned_emulator, :__struct__) and
               returned_emulator.__struct__ != Raxol.Terminal.Emulator
    end
  end
end
