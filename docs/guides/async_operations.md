# Asynchronous Operations in Raxol

Raxol provides mechanisms for handling asynchronous tasks like recurring events or background jobs without blocking the main application loop. This is achieved through Subscriptions and Commands.

## Subscriptions

Subscriptions allow your application to listen to external event streams or generate periodic events. You define them within the optional `subscribe/1` callback in your `Raxol.App` module.

**The `subscribe/1` Callback:**

- Takes the initial `model` returned by `init/1` as an argument.
- Returns a `Raxol.Subscription` struct, often a `batch` of multiple subscriptions.
- The runtime manages these subscriptions, sending messages generated by them to your `update/2` function.

**Example: Periodic Timer with `Raxol.Subscription.interval/3`**

A common use case is triggering an action at regular intervals. The `examples/basic/subscriptions.exs` shows how to increment a counter every second:

```elixir
defmodule MyApp.Subscriptions do
  use Raxol.App
  # ... other code ...

  @impl true
  def init(_flags) do
    %{count: 0}
  end

  # Define subscription after initialization
  @impl true
  def subscribe(model) do
    # Send the :tick message every 1000ms (1 second)
    Raxol.Subscription.interval(:tick, 1000, model)
  end

  @impl true
  def update(msg, model) do
    case msg do
      :tick ->
        %{model | count: model.count + 1} # Increment on :tick

      # ... other message handling ...
      _ ->
        model
    end
  end

  # ... render/1 ...
end
```

In this example:

1. `subscribe/1` is called once after `init/1`.
2. It returns `Raxol.Subscription.interval(:tick, 1000, model)`.
3. The Raxol runtime sets up a timer that sends the `:tick` message to `update/2` every 1000 milliseconds.
4. The `update/2` function handles the `:tick` message to update the application state.

Other types of subscriptions might listen to file system changes, external processes, or network events.

## Commands

Commands are used to perform one-off background tasks or potentially long-running operations without blocking the UI thread. Unlike subscriptions which are typically set up once, commands are usually initiated from the `update/2` function in response to user actions or other events.

**The Command Workflow:**

1.  **Initiation:** In your `update/2` function, when you need to perform a background task, return a tuple `{model, command}` instead of just the updated `model`.
2.  **Creation:** Create the `command` using `Raxol.Command.new/2`.
    - The first argument is a unique `tag` (an atom or other term) that you'll use to identify the result later.
    - The second argument is a 0-arity anonymous function (`fn -> ... end`) containing the code to be executed in the background. This function should perform the work and return the result.
3.  **Execution:** The Raxol runtime executes the function provided to `Raxol.Command.new/2` in a separate process.
4.  **Result Handling:** When the background function completes, it sends a message back to your `update/2` function in the format `{tag, result}`, where `tag` is the identifier you provided and `result` is the return value of your background function.
5.  **Update State:** Handle the `{tag, result}` message in `update/2` to process the result and update your application state accordingly.

**Example: Fetching Data (Conceptual)**

Let's adapt the idea from `examples/advanced/commands.exs` to a simpler fetching example:

```elixir
defmodule MyApp.Commands do
  use Raxol.App
  # ... other code ...

  @impl true
  def init(_flags) do
    %{data: "Loading...", status: :idle}
  end

  @impl true
  def update(msg, model) do
    case msg do
      # User clicks a "Fetch Data" button
      :fetch_data ->
        # Start the background task
        command = Raxol.Command.new(:data_fetched, fn ->
          # Simulate a network request or long computation
          Process.sleep(2000)
          {:ok, "Data from background task!"} # Return the result
        end)
        # Return the model (potentially updated) and the command
        {%{model | status: :loading}, command}

      # Handle the result from the background task
      {:data_fetched, {:ok, fetched_data}} ->
        # Update the model with the fetched data
        %{model | data: fetched_data, status: :idle}

      {:data_fetched, {:error, reason}} ->
        # Handle potential errors
        %{model | data: "Error fetching data: #{inspect(reason)}", status: :error}

      _ ->
        model # Return only the model for other messages
    end
  end

  # ... render/1 ...
end
```

In this flow:

1. Receiving `:fetch_data` triggers the command creation.
2. `Raxol.Command.new/2` is used with the tag `:data_fetched` and a function simulating work.
3. The `update/2` function returns `{updated_model, command}`.
4. Raxol runs the function in the background.
5. When done, a message like `{:data_fetched, {:ok, "Data from background task!"}}` is sent to `update/2`.
6. The corresponding clause in `update/2` handles the result.

Commands are essential for keeping your UI responsive while performing I/O operations or complex computations.
