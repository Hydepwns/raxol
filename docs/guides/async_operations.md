# Asynchronous Operations in Raxol

Raxol provides mechanisms for handling asynchronous tasks like recurring events or background jobs without blocking the main application loop. This is achieved through Subscriptions and Commands, typically managed via helpers provided when using `use Raxol.Core.Runtime.Application`.

## Subscriptions

Subscriptions allow your application to listen to external event streams or generate periodic events. You define them within the optional `subscribe/1` callback in your `Application` module (the module that `use Raxol.Core.Runtime.Application`).

**The `subscribe/1` Callback:**

- Takes the current `model` as an argument.
- Returns a list of `Raxol.Core.Runtime.Subscription` structs, often created using helper functions.
- The runtime manages these subscriptions, sending messages generated by them to your `update/2` function.

**Example: Periodic Timer with `Subscription.interval/2`**

A common use case is triggering an action at regular intervals.

```elixir
defmodule MyApp.Subscriptions do
  use Raxol.Core.Runtime.Application # Updated path
  # ... other code ...

  @impl true
  def init(_flags) do
    %{count: 0}
  end

  # Define subscription after initialization
  @impl true
  def subscribe(_model) do
    # Send the :tick message every 1000ms (1 second)
    # Helpers are available via `use Raxol.Core.Runtime.Application`
    # Or use the full module: Raxol.Core.Runtime.Subscription.interval(1000, :tick)
    subscribe_interval(1000, :tick) # Updated usage (helper)
  end

  @impl true
  def update(msg, model) do
    case msg do
      # The message defined in the subscription is sent directly
      :tick ->
        %{model | count: model.count + 1} # Increment on :tick

      # ... other message handling ...
      _ ->
        {model, []} # Update must return {model, commands}
    end
    |> case do # Ensure update always returns {model, commands}
      {m, c} -> {m, c}
      m -> {m, []}
    end
  end

  # ... view/1 ...
end
```

In this example:

1. `subscribe/1` is called after `init/1` and subsequent updates.
2. It returns `[subscribe_interval(1000, :tick)]` (assuming the helper is used).
3. The Raxol runtime sets up a timer that sends the `:tick` message to `update/2` every 1000 milliseconds.
4. The `update/2` function handles the `:tick` message to update the application state. Note that `update/2` must return a `{model, commands}` tuple.

Other types of subscriptions might listen to file system changes (`Subscription.file_watch/2`), system events (`Subscription.events/1`), or custom event sources (`Subscription.custom/2`). You can return multiple subscriptions from `subscribe/1` in a list.

## Commands

Commands are used to perform one-off background tasks or potentially long-running operations without blocking the UI thread. Commands are usually initiated from the `update/2` function by returning a tuple `{model, command_or_commands}`.

**The `Command.task/1` Workflow:**

A common way to run background work is using `Command.task/1`.

1.  **Initiation:** In your `update/2` function, when you need to perform a background task, return a command created with `Command.task/1` (or the `task/1` helper) in the second element of the `{model, commands}` tuple.
2.  **Task Function:** Provide `Command.task/1` with a 0-arity anonymous function (`fn -> ... end`) containing the code to be executed in the background. **Crucially, this function must return the message** that should be sent back to your `update/2` function upon completion.
3.  **Execution:** The Raxol runtime executes the function provided to `Command.task/1` in a separate process.
4.  **Result Handling:** When the background function completes, the **message it returned** is sent back to your `update/2` function.
5.  **Update State:** Handle the message returned by the task function in `update/2` to process the result and update your application state accordingly.

**Example: Fetching Data with `Command.task/1`**

```elixir
defmodule MyApp.Commands do
  use Raxol.Core.Runtime.Application # Updated path
  # ... other code ...

  @impl true
  def init(_flags) do
    {%{data: "Idle", status: :idle}, []} # init also returns {model, commands}
  end

  @impl true
  def update(msg, model) do
    case msg do
      # User clicks a "Fetch Data" button (assume :fetch_data is the message)
      :fetch_data ->
        # Start the background task using the task/1 helper
        command = task(fn ->
          # Simulate a network request or long computation
          Process.sleep(2000)
          result = {:ok, "Data from background task!"} # Or {:error, reason}
          # The task function returns the *message* to send back
          {:data_fetched, result}
        end)
        # Return the model (updated status) and the command
        {%{model | status: :loading, data: "Loading..."}, command}

      # Handle the message returned from the background task
      {:data_fetched, {:ok, fetched_data}} ->
        # Update the model with the fetched data
        {%{model | data: fetched_data, status: :idle}, []}

      {:data_fetched, {:error, reason}} ->
        # Handle potential errors
        {%{model | data: "Error: #{inspect(reason)}", status: :error}, []}

      _ ->
        {model, []} # Return model and empty commands for other messages
    end
  end

  # ... view/1 ...
end
```

In this flow:

1. Receiving `:fetch_data` triggers the command creation.
2. `Command.task/1` (via the `task/1` helper) is used with a function that performs the work and returns the _entire_ message, e.g., `{:data_fetched, {:ok, "Actual Data"}}`.
3. The `update/2` function returns `{updated_model, command}`.
4. Raxol runs the function in the background.
5. When done, the message _returned by the task function_ (e.g., `{:data_fetched, {:ok, "Actual Data"}}`) is sent to `update/2`.
6. The corresponding clause in `update/2` handles the result message.

Other commands exist for different side effects, such as batching commands (`Command.batch/1`), delaying messages (`Command.delay/2`), writing to the clipboard (`Command.clipboard_write/1`), reading from the clipboard (`Command.clipboard_read/0`), sending notifications (`Command.notify/1`), and quitting the application (`Command.quit/0`). These are typically created using helpers provided by `use Raxol.Core.Runtime.Application` or directly via the `Raxol.Core.Runtime.Command` module. Commands are essential for keeping your UI responsive while performing I/O operations or complex computations.
